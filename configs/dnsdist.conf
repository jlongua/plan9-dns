--[[
dnsdist config
initial setup - jlong 08/27/2022
    mkdir /var/lib/dnsdist
    nano /var/lib/dnsdist/serial => enter 1
    chown -R _dnsdist: /var/lib/dnsdist
  edit path to SSL certs:
    local fullchain and local privkey
  edit dnscrypt provider name:
    local provname - eg. 2.dnscrypt-cert.server1.example.com
print dnscrypt public key from console
  > printDNSCryptProviderFingerprint("/var/lib/dnsdist/providerPublic.key")
]]

function file_exists(name)
  local file = io.open(name, "r")
  if file ~= nil then
      io.close(file)
      return true
  else
      return false
  end
end

local f = io.open("/var/lib/dnsdist/serial", "r")
local serial = f:read("*n")
f:close()

-- path to SSL certs
local fullchain = "/etc/zerossl/plan9-dns.com_ecc/fullchain.pem"
local privkey = "/etc/zerossl/plan9-dns.com_ecc/private.key"
-- dnscrypt provider name
local provname = "2.dnscrypt-cert.server1.example.com"

setLocal("127.0.0.1:5353")

-- allow query from all IP addresses
addACL('0.0.0.0/0')
addACL('::/0')

SetDisableECSAction()

-- generate initial dnscrypt long time provider keys
if not file_exists(
  "/var/lib/dnsdist/providerPublic.key") or not file_exists(
  "/var/lib/dnsdist/providerPrivate.key") then
      generateDNSCryptProviderKeys(
          "/var/lib/dnsdist/providerPublic.key",
          "/var/lib/dnsdist/providerPrivate.key"
      )
end

-- generate initial dnscrypt short time resolver cert/key pair
if not file_exists(
  "/var/lib/dnsdist/resolver.cert") or not file_exists(
  "/var/lib/dnsdist/resolver.key") then
      generateDNSCryptCertificate(
          "/var/lib/dnsdist/providerPrivate.key",
          "/var/lib/dnsdist/resolver.cert",
          "/var/lib/dnsdist/resolver.key",
          serial, os.time() - 60, os.time() + 43200,
          DNSCryptExchangeVersion.VERSION2
      )
end

-- add a DoH resolver
addDOHLocal(
  "0.0.0.0",
  fullchain,
  privkey,
  "/dns-query",{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)
addDOHLocal(
  "[::]",
  fullchain,
  privkey,
  "/dns-query",{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)

-- add a DoT resolver
addTLSLocal(
  "0.0.0.0",
  fullchain,
  privkey,{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)
addTLSLocal(
  "[::]",
  fullchain,
  privkey,{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)

addDNSCryptBind(
  "0.0.0.0:8443",
  provname,
  "/var/lib/dnsdist/resolver.cert",
  "/var/lib/dnsdist/resolver.key",{
    maxConcurrentTCPConnections=250
    }
)

-- downstream resolvers
newServer({
    address="127.0.0.1:53",
    name="pdns-recursor",
    disableZeroScope=false,
    qps=0,
    pool=""
    }
)
newServer({
    address="209.244.0.3",
    name="level3",
    qps=25,
    pool="abuse"
    }
)
newServer({
    address="204.194.232.200",
    name="openDNS",
    qps=25,
    pool="abuse"
    }
)
newServer({
    address="1.1.1.1",
    name="cloudflare",
    qps=25,
    pool="abuse"
    }
)

pc = newPacketCache(
  100000,{
    maxTTL=86400,
    minTTL=0,
    temporaryFailureTTL=60,
    staleTTL=60,
    dontAge=false,
    parseECS=true
    }
)
getPool(""):setCache(pc)

setPoolServerPolicy(
  roundrobin,
  "abuse"
)

-- start of rulesets
--
-- drop incoming local queries
addAction({
    "lan.", "localdomain.","local."},
  SetTagAction(
    "local-queries-rule", "match"),{
    name="tag localQueries"
  }
)
addAction(
  TagRule(
    "local-queries-rule", "match"),
  DropAction(),{
    name="drop localQueries"
  }
)

-- drop local PTR queries
addAction(
  RegexRule(
    "168.192.in-addr.arpa"),
  SetTagAction(
    "localArp-queries-rule", "match"),{
    name="tag localArpQueries"
    }
  )
adddAction(
  TagRule(
    "localArp-queries-rule", "match"),
  DropAction(),{
    name="drop localArpQueries"
    }
  )

-- drop more than one question per query
addAction(
  NotRule(
    RecordsCountRule(
      DNSSection.Question, 1, 1)),
  SetTagAction(
    "one-question-rule", "match"),{
    name="tag oneQuestion"
    }
)
addAction(
  TagRule(
    "one-question-rule", "match"),
  DropAction(),{
    name="drop oneQuestion"
    }
)

addAction(
  RegexRule(
    "_ta-4f66"),
  DropAction(),{
    name="TYPE10 drop"
    }
)
addAction({
    "publicbt.com."},
  DropAction(),{
    name="publicbt drop"
    }
)

-- drop ANY udp queries
addAction(
  AndRule({
      QTypeRule(DNSQType.ANY),
      TCPRule(false)
      }),
  DropAction(),{
    name="ANY udp drop"
    }
)

--  truncate ANY tcp queries
addAction(
  AndRule({
      QTypeRule(DNSQType.ANY),
      TCPRule(true)
      }),
  TCAction(),{
    name="ANY tcp truncate"
    }
)

-- limitQueries netMaskGroup 
limitQueries=newNMG()
limitQueries:addMask('23.83.122.60/32')
limitQueries:addMask('8.39.234.175/32')
limitQueries:addMask('37.120.0.0/16')
limitQueries:addMask('45.79.197.134/32')
limitQueries:addMask('64.120.5.250/32')
limitQueries:addMask('70.36.170.112/32')
limitQueries:addMask('86.106.74.218/32')
limitQueries:addMask('89.38.131.38/32')
limitQueries:addMask('91.193.4.168/32')
limitQueries:addMask('91.219.215.226/32')
limitQueries:addMask('94.198.41.234/32')
limitQueries:addMask('2a0b:f300:406::/128')
-- tag and limit limitQueries to 25qps
addAction(
  NetmaskGroupRule(limitQueries, true),
  SetTagAction(
    "limit-queries-rule", "match"),{
    name="tag limitQueries"
    }
)
addAction(
  TagRule(
    "limit-queries-rule", "match"),
  QPSAction(25),{
    name="qps25 limitQueries"
    }
)

-- prevent domains being sent to abuse pool
addAction({
  'browserleaks.org.', 'browserleaks.com.', 'ipleak.net.', 'dnsleaktest.com.'
  },
    QPSAction(40),{
    name="leaktest"
    }
)

-- truncate global over 70 qpsip
addAction(
  AndRule({
      MaxQPSIPRule(70),
      TCPRule(false)
      }), 
  SetTagAction(
    "global-qpsip-rule", "match"),{
    name="tag global-qpsip"
    }
)
addAction(
  TagRule(
    "global-qpsip-rule", "match"), 
  TCAction(),{
    name="truncate global-qpsip"
    }
)

-- maxQueries netMaskGroup
maxQueries=newNMG()
maxQueries:addMask('0.0.0.0/0')
maxQueries:addMask('!xxx.xxx.xxx.125/32') -- add !ip to exclude from MaxQPSIPRule
maxQueries:addMask('!xxx.xxx.xxx.59/32') -- add !ip to exclude from MaxQPSIPRule
maxQueries:addMask('::/0')
maxQueries:addMask('!xxxx:xxxx:xxxx:xxxx:xxxx:4ff:fe0c:3ffe/128') -- add !ip to exclude from MaxQPSIPRule
-- tag and send maxQueries excluding !ip masks) to abuse pool
addAction(
  AndRule({
      NetmaskGroupRule(maxQueries, true),
      MaxQPSIPRule(50)
      }),
  SetTagAction(
    "max-queries-rule", "match"),{
    name="tag maxQueries"
    }
)
addAction(
  TagRule(
    "max-queries-rule", "match"),
  PoolAction('abuse'),{
    name="abuse pool maxQueries"
    }
)

-- dynBlock
local dbr = dynBlockRulesGroup()
dbr:excludeRange({
    "127.0.0.1/32",
    "45.77.99.125/32"
    }
)
dbr:setQueryRate(
  70, 10,
  "Exceeded Query rate",
  75, DNSAction.Drop
)
dbr:setRCodeRate(
  DNSRCode.NXDOMAIN, 10, 10,
  "Exceeded NXD rate",
  60, DNSAction.Drop
)
dbr:setRCodeRate(
  DNSRCode.SERVFAIL, 10, 10,
  "Exceeded ServFail rate",
  60, DNSAction.Drop
)
dbr:setQTypeRate(
  DNSQType.ANY, 10, 10,
  "Exceeded ANY rate",
  60, DNSAction.Drop
)
dbr:setQTypeRate(
  DNSQType.TXT, 10, 10,
  "Exceeded TXT rate",
  60, DNSAction.Drop
)
dbr:setQTypeRate(
  DNSQType.NS, 10, 10,
  "Exceeded NS rate",
  60, DNSAction.Drop
)
dbr:setResponseByteRate(
  15000, 10,
  "Exceeded resp BW rate",
  75, DNSAction.Drop
)

-- dnscrypt cert rotation
local last = os.time() - 14400
function maintenance()
  local now = os.time()
  if ((now - last) > 21600) then
      serial = serial + 1
      generateDNSCryptCertificate(
          "/var/lib/dnsdist/providerPrivate.key",
          "/var/lib/dnsdist/resolver.cert",
          "/var/lib/dnsdist/resolver.key",
          serial, now - 60, now + 43200,
          DNSCryptExchangeVersion.VERSION2
          )
      getDNSCryptBind(0):loadNewCertificate(
          '/var/lib/dnsdist/resolver.cert',
          '/var/lib/dnsdist/resolver.key'
          )
      last = now
      local f = io.open("/var/lib/dnsdist/serial", "w")
      f:write(serial)
      f:close()
  end
  dbr:apply()
end

-- enable local control socket, generate key with makeKey()
controlSocket('127.0.0.1:5199')
setKey("passKey=")

webserver("0.0.0.0:8083")
setWebserverConfig({
  password=(
    "$scrypt$ln=10,p=1,r=8$passWord="),
  apiKey=(
    "$scrypt$ln=10,p=1,r=8$passKey="),
  acl="0.0.0.0/0"
  }
)
