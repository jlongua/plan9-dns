--[[ 
dnsdist config
initial setup - jlong v0.9.0 08/27/2022
    mkdir /var/lib/dnsdist
    nano /var/lib/dnsdist/serial => enter 1
    chown -R _dnsdist: /var/lib/dnsdist
  edit local fullchain and local privkey
  edit local provname - eg. 2.dnscrypt-cert.example.com 
print dnscrypt public key from console
  > printDNSCryptProviderFingerprint("/var/lib/dnsdist/providerPublic.key")
]]

function file_exists(name)
  local file = io.open(name, "r")
  if file ~= nil then
      io.close(file)
      return true
  else
      return false
  end
end

local f = io.open("/var/lib/dnsdist/serial", "r")
local serial = f:read("*n")
f:close()

-- path to SSL certs
local fullchain = "/etc/zerossl/plan9-dns.com_ecc/fullchain.pem"
local privkey = "/etc/zerossl/plan9-dns.com_ecc/private.key"
-- dnscrypt provider name
local provname = "2.dnscrypt-cert.server1.example.com"

-- generate initial dnscrypt long time provider keys
if not file_exists(
  "/var/lib/dnsdist/providerPublic.key") or not file_exists(
  "/var/lib/dnsdist/providerPrivate.key") then
      generateDNSCryptProviderKeys(
          "/var/lib/dnsdist/providerPublic.key",
          "/var/lib/dnsdist/providerPrivate.key"
      )
end

-- generate initial dnscrypt short time resolver cert/key pair
if not file_exists(
  "/var/lib/dnsdist/resolver.cert") or not file_exists(
  "/var/lib/dnsdist/resolver.key") then
      generateDNSCryptCertificate(
          "/var/lib/dnsdist/providerPrivate.key",
          "/var/lib/dnsdist/resolver.cert",
          "/var/lib/dnsdist/resolver.key",
          serial, os.time() - 60, os.time() + 43200,
          DNSCryptExchangeVersion.VERSION2
      )
end

setLocal("127.0.0.1:5353")

-- allow query from all IP addresses
addACL('0.0.0.0/0')
addACL('::/0')

SetDisableECSAction()

-- add a DoH resolver
addDOHLocal(
  "0.0.0.0", fullchain, privkey,
  {"/dns-query"},
  {reusePort=true, tcpFastOpenSize=0, minTLSVersion='tls1.2'}
)
addDOHLocal(
  "[::]", fullchain, privkey,
  {"/dns-query"},
  {reusePort=true, tcpFastOpenSize=0, minTLSVersion='tls1.2'}
)

-- add a DoT resolver
addTLSLocal(
  "0.0.0.0", fullchain, privkey,
   {reusePort=true, tcpFastOpenSize=0, minTLSVersion='tls1.2'}
)
addTLSLocal(
  "[::]", fullchain, privkey,
   {reusePort=true, tcpFastOpenSize=0, minTLSVersion='tls1.2'}
)

addDNSCryptBind(
  "0.0.0.0:8443",
  provname,
  "/var/lib/dnsdist/resolver.cert",
  "/var/lib/dnsdist/resolver.key",
  {maxConcurrentTCPConnections=250}
)

-- downstream resolvers
newServer(
  {address="127.0.0.1:53",qps=0, name="pdns-recursor", disableZeroScope=false, pool=""}
)
newServer(
  {address="209.244.0.3", qps=25, name="level3", pool="abuse"}
)
newServer(
  {address="204.194.232.200", qps=25, name="openDNS", pool="abuse"}
)
newServer(
  {address="1.1.1.1", qps=25, name="cloudflare", pool="abuse"}
)

pc = newPacketCache(
  100000,
  {maxTTL=86400, minTTL=0, temporaryFailureTTL=60, staleTTL=60, dontAge=false, parseECS=true}
)
getPool(""):setCache(pc)

setPoolServerPolicy(
  roundrobin, "abuse"
)

-- send MaxQPSIP (excluding !ip masks) to abuse pool
maxQueries=newNMG()
maxQueries:addMask('0.0.0.0/0')
-- maxQueries:addMask('!xx.xx.99.125/32')  -- add !ip to exclude from MaxQPSIPRule(40)
-- maxQueries:addMask('!xx.xx.111.59/32')  -- add !ip to exclude from MaxQPSIPRule(40)
maxQueries:addMask('::/0')
-- maxQueries:addMask('!xxxx:xxxx:xxxx:34bc:6300:4ff:fe0c:3ffe/128')  -- add !ip to exclude from MaxQPSIPRule(40)
addAction(AndRule(
  {NetmaskGroupRule(maxQueries, true), MaxQPSIPRule(40)}),
  PoolAction('abuse')
)
--  drop ANY udp queries
addAction(AndRule(
  {QTypeRule(DNSQType.ANY), TCPRule(false)}),
  DropAction()
)
--  truncate ANY tcp queries
addAction(AndRule(
  {QTypeRule(DNSQType.ANY), TCPRule(true)}),
  TCAction()
)

-- dynBlock
local dbr = dynBlockRulesGroup()
dbr:excludeRange(
  {"127.0.0.1/32"}
)
dbr:setQueryRate(
  100, 10, "Exceeded query rate", 1, DNSAction.NoOp
)
dbr:setRCodeRate(
  DNSRCode.NXDOMAIN, 20, 10, "Exceeded NXD rate", 5
)
dbr:setRCodeRate(
  DNSRCode.SERVFAIL, 20, 10, "Exceeded ServFail rate", 5
)
dbr:setQTypeRate(
  DNSQType.ANY, 10, 10, "Exceeded ANY rate", 5
)
dbr:setResponseByteRate(
  15000, 10, "Exceeded resp BW rate", 1, DNSAction.NoOp
)

-- dnscrypt cert rotation
local last = os.time() - 7200
function maintenance()
  local now = os.time()
  if ((now - last) > 21600) then
      serial = serial + 1
      generateDNSCryptCertificate(
          "/var/lib/dnsdist/providerPrivate.key",
          "/var/lib/dnsdist/resolver.cert",
          "/var/lib/dnsdist/resolver.key",
          serial, now - 60, now + 43200,
          DNSCryptExchangeVersion.VERSION2
      )
      getDNSCryptBind(0):loadNewCertificate(
          '/var/lib/dnsdist/resolver.cert',
          '/var/lib/dnsdist/resolver.key'
      )
      last = now
      local f = io.open("/var/lib/dnsdist/serial", "w")
      f:write(serial)
      f:close()
  end
  dbr:apply()
end

-- enable local control socket, generate key with makeKey()
controlSocket('127.0.0.1:5199')
setKey("yourkey=")

webserver("0.0.0.0:8083")
setWebserverConfig(
  {password="$scrypt$ln=10,p=1,r=8$hashed==$password=",
    apiKey="$scrypt$ln=10,p=1,r=8$hashed==$password=",
    acl="0.0.0.0/0"}
)
