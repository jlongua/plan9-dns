--[[ 
dnsdist config
initial setup - jlong 08/27/2022
    mkdir /var/lib/dnsdist
    nano /var/lib/dnsdist/serial => enter 1
    chown -R _dnsdist: /var/lib/dnsdist
  edit local fullchain and local privkey
  edit local provname - eg. 2.dnscrypt-cert.example.com 
print dnscrypt public key from console
  > printDNSCryptProviderFingerprint("/var/lib/dnsdist/providerPublic.key")
]]

function file_exists(name)
  local file = io.open(name, "r")
  if file ~= nil then
      io.close(file)
      return true
  else
      return false
  end
end

local f = io.open("/var/lib/dnsdist/serial", "r")
local serial = f:read("*n")
f:close()

-- path to SSL certs
local fullchain = "/etc/zerossl/plan9-dns.com_ecc/fullchain.pem"
local privkey = "/etc/zerossl/plan9-dns.com_ecc/private.key"
-- dnscrypt provider name
local provname = "2.dnscrypt-cert.server1.example.com"

setLocal("127.0.0.1:5353")

-- allow query from all IP addresses
addACL('0.0.0.0/0')
addACL('::/0')

SetDisableECSAction()

-- generate initial dnscrypt long time provider keys
if not file_exists(
  "/var/lib/dnsdist/providerPublic.key") or not file_exists(
  "/var/lib/dnsdist/providerPrivate.key") then
      generateDNSCryptProviderKeys(
          "/var/lib/dnsdist/providerPublic.key",
          "/var/lib/dnsdist/providerPrivate.key"
      )
end

-- generate initial dnscrypt short time resolver cert/key pair
if not file_exists(
  "/var/lib/dnsdist/resolver.cert") or not file_exists(
  "/var/lib/dnsdist/resolver.key") then
      generateDNSCryptCertificate(
          "/var/lib/dnsdist/providerPrivate.key",
          "/var/lib/dnsdist/resolver.cert",
          "/var/lib/dnsdist/resolver.key",
          serial, os.time() - 60, os.time() + 43200,
          DNSCryptExchangeVersion.VERSION2
      )
end

-- add a DoH resolver
addDOHLocal(
  "0.0.0.0",
  fullchain,
  privkey,
  "/dns-query",{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)
addDOHLocal(
  "[::]",
  fullchain,
  privkey,
  "/dns-query",{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)

-- add a DoT resolver
addTLSLocal(
  "0.0.0.0",
  fullchain,
  privkey,{
    reusePort=true,
    tcpFastOpenSize=0,
    minTLSVersion='tls1.2'
    }
)
addTLSLocal(
  "[::]",
  fullchain,
  privkey,{
    reusePort=true,
    tcpFastOpenSize=0, 
    minTLSVersion='tls1.2'
    }
)

addDNSCryptBind(
  "0.0.0.0:8443",
  provname,
  "/var/lib/dnsdist/resolver.cert",
  "/var/lib/dnsdist/resolver.key",{
    maxConcurrentTCPConnections=250
    }
)

-- downstream resolvers
newServer({
    address="127.0.0.1:53",
    name="pdns-recursor",
    disableZeroScope=false,
    qps=0,
    pool=""
    }
)
newServer({
    address="149.112.112.112:853",
    tls="openssl",
    subjectName="dns.quad9.net",
    name="quad9-DoT",
    qps=25,
    pool="abuse"
    }
)
newServer({
    address="208.67.222.222:443",
    tls="openssl",
    dohPath="/dns-query",
    subjectName="doh.opendns.com",
    name="openDNS-DoH",
    qps=25,
    pool="abuse"
    }
)
newServer({
    address="1.1.1.1:853",
    tls="openssl",
    subjectName="1dot1dot1dot1.cloudflare-dns.com",
    name="cloudflare-DoT",
    qps=25,
    pool="abuse"
    }
)

pc = newPacketCache(
  100000,{
    maxTTL=86400,
    minTTL=0,
    temporaryFailureTTL=60,
    staleTTL=60,
    dontAge=false,
    parseECS=true
    }
)
getPool(""):setCache(pc)

setPoolServerPolicy(
  roundrobin,
  "abuse"
)

-- send MaxQPSIP (excluding !ip masks) to abuse pool
maxQueries=newNMG()
maxQueries:addMask('0.0.0.0/0')
-- maxQueries:addMask('!xx.xx.99.125/32')  -- add !ip to exclude from MaxQPSIPRule
-- maxQueries:addMask('!xx.xx.111.59/32')  -- add !ip to exclude from MaxQPSIPRule
maxQueries:addMask('::/0')
-- maxQueries:addMask('!xxxx:xxxx:xxxx:34bc:6300:4ff:fe0c:3ffe/128')  -- add !ip to exclude from MaxQPSIPRule
addAction(AndRule({
      NetmaskGroupRule(maxQueries, true),
      MaxQPSIPRule(50)
      }),
  PoolAction('abuse'),{
    name="MaxQPSIP !masks"
    }
)

--  drop ANY udp queries
addAction(AndRule({
      QTypeRule(DNSQType.ANY),
      TCPRule(false)
      }),
  DropAction(),{
    name="ANY udp drop"
    }
)
--  truncate ANY tcp queries
addAction(AndRule({
      QTypeRule(DNSQType.ANY),
      TCPRule(true)
      }),
  TCAction(),{
    name="ANY tcp truncate"
    }
)

-- dynBlock
local dbr = dynBlockRulesGroup()
dbr:excludeRange(
  {"127.0.0.1/32"}
)
dbr:setQueryRate(
  70, 10, "Exceeded query rate", 360, DNSAction.Drop
)
dbr:setRCodeRate(
  DNSRCode.NXDOMAIN, 20, 10, "Exceeded NXD rate", 30, DNSAction.Drop
)
dbr:setRCodeRate(
  DNSRCode.SERVFAIL, 20, 10, "Exceeded ServFail rate", 30, DNSAction.Drop
)
dbr:setQTypeRate(
  DNSQType.ANY, 10, 10, "Exceeded ANY rate", 30, DNSAction.Drop
)
dbr:setResponseByteRate(
  12000, 10, "Exceeded resp BW rate", 360, DNSAction.Drop
)

-- dnscrypt cert rotation
local last = os.time() - 7200
function maintenance()
  local now = os.time()
  if ((now - last) > 21600) then
      serial = serial + 1
      generateDNSCryptCertificate(
          "/var/lib/dnsdist/providerPrivate.key",
          "/var/lib/dnsdist/resolver.cert",
          "/var/lib/dnsdist/resolver.key",
          serial, now - 60, now + 43200,
          DNSCryptExchangeVersion.VERSION2
      )
      getDNSCryptBind(0):loadNewCertificate(
          '/var/lib/dnsdist/resolver.cert',
          '/var/lib/dnsdist/resolver.key'
      )
      last = now
      local f = io.open("/var/lib/dnsdist/serial", "w")
      f:write(serial)
      f:close()
  end
  dbr:apply()
end

-- enable local control socket, generate key with makeKey()
controlSocket('127.0.0.1:5199')
setKey("yourkey=")

webserver("0.0.0.0:8083")
setWebserverConfig(
  {password="$scrypt$ln=10,p=1,r=8$hashed==$password=",
    apiKey="$scrypt$ln=10,p=1,r=8$hashed==$password=",
    acl="0.0.0.0/0"}
)
