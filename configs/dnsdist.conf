--[[
dnsdist config
initial setup - jlong 08/27/2022
    mkdir /var/lib/dnsdist
    nano /var/lib/dnsdist/serial => enter 1
    chown -R _dnsdist: /var/lib/dnsdist
    edit local fullchain and local privkey
    edit local provname - eg. 2.dnscrypt-cert.example.com
print dnscrypt public key from console
> printDNSCryptProviderFingerprint("/var/lib/dnsdist/providerPublic.key")
]]

function file_exists(name)
    local file = io.open(name, "r")
    if file ~= nil then
        io.close(file)
        return true
    else
        return false
    end
end

local f = io.open("/var/lib/dnsdist/serial", "r")
local serial = f:read("*n")
f:close()

-- path to SSL certs
local fullchain = "/etc/zerossl/example.com_ecc/fullchain.pem"
local privkey = "/etc/zerossl/example.com_ecc/private.key"
-- dnscrypt provider name
local provname = "2.dnscrypt-cert.sub.example.com"

setLocal("127.0.0.1:5353")

-- allow query from all IP addresses
addACL('0.0.0.0/0')
addACL('::/0')

SetDisableECSAction()

-- generate initial dnscrypt long time provider keys
if not file_exists(
        "/var/lib/dnsdist/providerPublic.key") or not file_exists(
        "/var/lib/dnsdist/providerPrivate.key") then 
    generateDNSCryptProviderKeys(
        "/var/lib/dnsdist/providerPublic.key",
        "/var/lib/dnsdist/providerPrivate.key")
end

-- generate initial dnscrypt short time resolver cert/key pair
if not file_exists(
        "/var/lib/dnsdist/resolver.cert") or not file_exists(
        "/var/lib/dnsdist/resolver.key") then
    generateDNSCryptCertificate(
        "/var/lib/dnsdist/providerPrivate.key",
        "/var/lib/dnsdist/resolver.cert",
        "/var/lib/dnsdist/resolver.key",
        serial, os.time() - 60, os.time() + 43200,
        DNSCryptExchangeVersion.VERSION2)
end

-- add a DoH resolver
addDOHLocal(
    "0.0.0.0",
    fullchain,
    privkey,
    "/dns-query",{
        reusePort=true,
        tcpFastOpenSize=0,
        minTLSVersion='tls1.2'
    }
)
addDOHLocal(
    "[::]",
    fullchain,
    privkey,
    "/dns-query",{
        reusePort=true,
        tcpFastOpenSize=0,
        minTLSVersion='tls1.2'
    }
)

-- add a DoT resolver
addTLSLocal(
    "0.0.0.0",
    fullchain,
    privkey,{
        reusePort=true,
        tcpFastOpenSize=0,
        minTLSVersion='tls1.2'
    }
)
addTLSLocal(
    "[::]",
    fullchain,
    privkey,{
        reusePort=true,
        tcpFastOpenSize=0,
        minTLSVersion='tls1.2'
    }
)

addDNSCryptBind(
    "0.0.0.0:8443",
    provname,
    "/var/lib/dnsdist/resolver.cert",
    "/var/lib/dnsdist/resolver.key",{
        maxConcurrentTCPConnections=250
    }
)

-- downstream resolvers
newServer({
    address="127.0.0.1:53",
    name="pdns-recursor",
    disableZeroScope=false,
    qps=0,
    pool=""
    }
)
newServer({
    address="209.244.0.3",
    name="level3",
    qps=25,
    pool="abuse"
    }
)
newServer({
    address="204.194.232.200",
    name="openDNS",
    qps=25,
    pool="abuse"
    }
)
newServer({
    address="1.1.1.1",
    name="cloudflare",
    qps=25,
    pool="abuse"
    }
)

pc = newPacketCache(
    100000,{
        maxTTL=86400,
        minTTL=0,
        temporaryFailureTTL=60,
        staleTTL=60,
        dontAge=false,
        parseECS=true
    }
)
getPool(""):setCache(pc)

setPoolServerPolicy(
    roundrobin,
    "abuse"
)

-- start of rulesets
--
-- drop more than one question per query
addAction(
    NotRule(
        RecordsCountRule(DNSSection.Question, 1, 1)),
    DropAction(),{
        name="drop oneQuestion"
    }
)
-- drop local queries
addAction({
        "lan.",
        "local.",
        "localdomain."},
    DropAction(),{
        name="drop localQueries"
    }
)
-- drop local PTR queries
addAction(
    RegexRule(
        "168.192.in-addr.arpa"),
    DropAction(),{
        name="drop localArpQueries"
    }
)
addAction(
    RegexRule(
        "1.0.0.127."),
    DropAction(),{
        name="drop localHostQueries"
    }
)
addAction(
    RegexRule(
        "iranserver"),
    RCodeAction(
        DNSRCode.REFUSED),{
            name="refuse iranserverQueries"
    }
)
addAction(
    RegexRule(
        "irancell"),
    RCodeAction(
        DNSRCode.REFUSED),{
            name="refuse irancellQueries"
    }
)
addAction(
    RegexRule(
        "[0-9]{1,}.all.s5h.net$"),
    DropAction(),{
        name="drop s5hQueries"
    }
)
addAction(
    RegexRule(
        "_ta-4f66"),
    DropAction(),{
        name="drop TYPE10"
    }
)
addAction({
        "publicbt.com.",
        "calmzxyn21.xyz."},
    DropAction(),{
        name="drop NXD"
    }
)
-- drop ANY udp queries
addAction(
    AndRule({
        QTypeRule(DNSQType.ANY),
        TCPRule(false)}),
    DropAction(),{
        name="drop ANY udp"
    }
)
--  truncate ANY tcp queries
addAction(
    AndRule({
        QTypeRule(DNSQType.ANY),
        TCPRule(true)}),
    TCAction(),{
        name="truncate ANY tcp"
    }
)

-- prevent domains being sent to abuse pool
addAction({
        'browserleaks.org.',
        'browserleaks.com.',
        'dnsleaktest.com.',
        'ipleak.net.'},
    QPSAction(80),{
        name="leaktest"
    }
)
addAction({
        "103.150.86.0/23"},
    SetNoRecurseAction(),{
        name="noRecurse Abuse"
    }
)
addAction({
        "91.227.188.0/22"},
    SetNoRecurseAction(),{
        name="noRecurse Abuse"
    }
)
addAction({
        "23.83.122.60/32"},
    QPSAction(20),{
        name="MaxAbuse"
    }
)

-- truncate global over 120 qpsip
addAction(
    AndRule({
        MaxQPSIPRule(120),
        TCPRule(false)}), 
    TCAction(),{
        name="truncate global-qpsip"
    }
)

-- send maxQueries excluding !ip masks) to abuse pool
maxQueries=newNMG()
maxQueries:addMask('0.0.0.0/0')
maxQueries:addMask('!111.222.111.222/32')
maxQueries:addMask('!112.222.112.222/32')
maxQueries:addMask('::/0')
maxQueries:addMask('!2006:40af:4:53df:4500:5dd:12da:12ca/128')
addAction(
    AndRule({
        NetmaskGroupRule(maxQueries, true),
        MaxQPSIPRule(100)}),
    PoolAction('abuse'),{
        name="abuse pool maxQueries"
    }
)

-- dynBlock
local dbr = dynBlockRulesGroup()
dbr:excludeRange({
    "127.0.0.1/32",
    "111.222.111.222/32"
    }
)
dbr:setQueryRate(
    120, 10,
    "Exceeded Query rate",
    75, DNSAction.Drop
)
dbr:setRCodeRate(
    DNSRCode.NXDOMAIN, 10, 10,
    "Exceeded NXD rate",
    60, DNSAction.Drop
)
dbr:setRCodeRate(
    DNSRCode.SERVFAIL, 10, 10,
    "Exceeded ServFail rate",
    60, DNSAction.Drop
)
dbr:setQTypeRate(
    DNSQType.ANY, 5, 10,
    "Exceeded ANY rate",
    60, DNSAction.Drop
)
dbr:setQTypeRate(
    DNSQType.TXT, 5, 10,
    "Exceeded TXT rate",
    60, DNSAction.Drop
)
dbr:setQTypeRate(
    DNSQType.PTR, 5, 10,
    "Exceeded PTR rate",
    60, DNSAction.Drop
)
dbr:setQTypeRate(
    DNSQType.NS, 20, 10,
    "Exceeded NS rate",
    60, DNSAction.Drop
)
dbr:setQTypeRate(
    DNSQType.DS, 20, 10,
    "Exceeded DS rate",
    60, DNSAction.Drop
)
dbr:setResponseByteRate(
    20000, 10,
    "Exceeded resp BW rate",
    75, DNSAction.Drop
)

-- dnscrypt cert rotation
local last = os.time() - 14400
function maintenance()
    local now = os.time()
        if ((now - last) > 21600) then
            serial = serial + 1
            generateDNSCryptCertificate(
                "/var/lib/dnsdist/providerPrivate.key",
                "/var/lib/dnsdist/resolver.cert",
                "/var/lib/dnsdist/resolver.key",
                serial, now - 60, now + 43200,
                DNSCryptExchangeVersion.VERSION2)
            getDNSCryptBind(0):loadNewCertificate(
                '/var/lib/dnsdist/resolver.cert',
                '/var/lib/dnsdist/resolver.key')
            last = now
            local f = io.open("/var/lib/dnsdist/serial", "w")
            f:write(serial)
            f:close()
        end
    dbr:apply()
end

-- enable local control socket, generate key with makeKey()
controlSocket('127.0.0.1:5199')
setKey("passkey=")

webserver("0.0.0.0:8083")
setWebserverConfig({
  password=(
    "$scrypt$ln=10,p=1,r=8$password="),
  apiKey=(
    "$scrypt$ln=10,p=1,r=8$apiKey="),
  acl="0.0.0.0/0"
  }
)
